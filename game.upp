global
profile math
capability io
entry Game

# ==========================================
# ULTRA C++ GAME ENGINE - ROGUELIKE DEMO
# ==========================================
# Este archivo demuestra la potencia de Ultra C++ para crear juegos
# con arquitectura modular, ECS simplificado y renderizado en consola.

# ------------------------------------------
# 1. Checklist Visual y Debug
# ------------------------------------------
class Checklist:
    def print_status(self):
        native "
        std::cout << \"\\n=== CHECKLIST DE CARACTERÍSTICAS ===\\n\";
        std::cout << \"[✔️] Configuración (Ventana/FPS)\\n\";
        std::cout << \"[✔️] Estados (Menu, Juego, Pausa, Fin)\\n\";
        std::cout << \"[✔️] Sistema de Entidades/Componentes\\n\";
        std::cout << \"[✔️] Input No Bloqueante (Win32)\\n\";
        std::cout << \"[✔️] Física y Colisiones AABB\\n\";
        std::cout << \"[✔️] Puntuación y Logs\\n\";
        std::cout << \"====================================\\n\";
        "

# ------------------------------------------
# 2. Sistema de Componentes (ECS Simplificado)
# ------------------------------------------
# Simulamos componentes mediante herencia y flags por ahora
# En el futuro, Ultra C++ soportará templates completos.

class TransformComponent:
    x: Float
    y: Float
    def __init__(x: Float, y: Float):
        self.x = x
        self.y = y

class StatsComponent:
    hp: Int
    max_hp: Int
    damage: Int
    def __init__(hp: Int, dmg: Int):
        self.hp = hp
        self.max_hp = hp
        self.damage = dmg

# ------------------------------------------
# 3. Entidades Base
# ------------------------------------------
class Entity:
    x: Float
    y: Float
    symbol: String
    active: Bool
    
    def __init__(x: Float, y: Float):
        self.x = x
        self.y = y
        self.symbol = "?"
        self.active = true

    def render(self):
        native "if(this->active) std::cout << this->symbol;"

# ------------------------------------------
# 4. Jugador y Enemigos
# ------------------------------------------
class Player : Entity:
    score: Int
    hp: Int
    max_hp: Int
    
    def __init__(self):
        native "
        this->x = 1.0; 
        this->y = 1.0; 
        this->symbol = \"@\"; 
        this->score = 0;
        this->hp = 100;
        this->max_hp = 100;
        this->active = true;
        "
    
    def move(self, dx: Float, dy: Float):
        native "this->x += dx; this->y += dy;"
    
    def heal(self, amount: Int):
        native "this->hp += amount; if(this->hp > this->max_hp) this->hp = this->max_hp;"

    def take_damage(self, amount: Int):
        native "this->hp -= amount; if(this->hp < 0) this->hp = 0;"

class Enemy(Entity):
    damage: Int
    
    def __init__(self, x: Float, y: Float):
        native "
        this->x = x; 
        this->y = y; 
        this->symbol = \"E\"; 
        this->active = true;
        this->damage = 10;
        "

# ------------------------------------------
# 5. Motor del Juego (Game Loop & States)
# ------------------------------------------
class Game:
    running: Bool
    state: Int  # 0: Menu, 1: Playing, 2: GameOver, 3: Pause
    width: Int
    height: Int
    frame_count: Int
    checklist: Checklist
    
    def __init__(self):
        native "
        this->running = true;
        this->state = 0; // Menu
        this->width = 20;
        this->height = 10;
        this->frame_count = 0;
        "
    
    def clear_screen(self):
        native "
        #ifdef _WIN32
            system(\"cls\");
        #else
            system(\"clear\");
        #endif
        "

    def log(self, msg: String):
        native "std::cout << \"[LOG] \" << msg << std::endl;"

    # Física y Colisiones
    def check_collisions(self, p: Player, e: Enemy):
        native "
        if (!e.active) return;
        float dx = p.x - e.x;
        float dy = p.y - e.y;
        if (std::abs(dx) < 0.5 && std::abs(dy) < 0.5) {
            this->log(\"¡Combate! Has recibido daño.\");
            p.take_damage(e.damage);
            e.active = false; // Enemigo derrotado
            p.score += 50;
        }
        "

    def draw_ui(self, p: Player):
        native "
        std::cout << \" Ultra C++ Roguelike | Score: \" << p.score << \" | HP: \" << p.hp << \"/\" << p.max_hp << \"\\n\";
        if (this->state == 3) std::cout << \" [PAUSA] - Presiona P para continuar\\n\";
        "

    def draw_map(self, p: Player, e: Enemy):
        self.clear_screen()
        self.draw_ui(p)
        native "
        std::cout << \"+\";
        for(int i=0; i<this->width; i++) std::cout << \"-\";
        std::cout << \"+\\n\";

        for(int y=0; y<this->height; y++) {
            std::cout << \"|\";
            for(int x=0; x<this->width; x++) {
                bool drawn = false;
                if (std::abs(x - (int)p.x) == 0 && std::abs(y - (int)p.y) == 0) {
                    std::cout << p.symbol;
                    drawn = true;
                } else if (e.active && std::abs(x - (int)e.x) == 0 && std::abs(y - (int)e.y) == 0) {
                    std::cout << e.symbol;
                    drawn = true;
                }
                
                if (!drawn) std::cout << \".\";
            }
            std::cout << \"|\\n\";
        }
        std::cout << \"+\";
        for(int i=0; i<this->width; i++) std::cout << \"-\";
        std::cout << \"+\\n\";
        std::cout << \"WASD: Mover | P: Pausa | Q: Salir\\n\";
        "

    def is_alive(self, p: Player) -> Bool:
        return not (p.hp <= 0) and self.state == 1

    def math_demo(self) -> Int:
        let a: Int = 1
        let b: Int = 2
        return a + b

    def input_update(self, p: Player):
        native "
        #ifdef _WIN32
        if (_kbhit()) {
            char input = _getch();
            if (this->state == 0) { // Menu
                if (input == 13) this->state = 1; // Enter
                if (input == 'q') this->running = false;
            } else if (this->state == 1) { // Playing
                float dx = 0; float dy = 0;
                if (input == 'w') dy = -1;
                else if (input == 's') dy = 1;
                else if (input == 'a') dx = -1;
                else if (input == 'd') dx = 1;
                else if (input == 'p') this->state = 3;
                else if (input == 'q') this->running = false;
                
                // Predicción y colisión con muros
                float new_x = p.x + dx;
                float new_y = p.y + dy;
                if (new_x >= 0 && new_x < this->width) p.x = new_x;
                if (new_y >= 0 && new_y < this->height) p.y = new_y;
            } else if (this->state == 2) { // Game Over
                 if (input == 'q') this->running = false;
                 if (input == 13) { // Reset
                     this->state = 1;
                     p.hp = 100; p.score = 0; p.x = 1; p.y = 1;
                 }
            } else if (this->state == 3) { // Pause
                if (input == 'p') this->state = 1;
            }
        }
        #else
            // Fallback simple para Linux/Mac (requiere Enter)
            char input;
            std::cin >> input;
            // ... lógica simplificada ...
        #endif
        "

    def run_loop(self):
        native "
        Checklist list;
        list.print_status();
        std::cout << \"Presione Enter para iniciar el juego...\";
        
        Player p;
        Enemy e(15.0, 5.0);
        
        while(this->running) {
            if (this->state == 0) { // Menu
                // Esperando start (handled in input)
                #ifdef _WIN32
                if (_kbhit()) {
                     char c = _getch();
                     if (c == 13) this->state = 1;
                }
                #else
                std::cin.get(); this->state = 1;
                #endif
            }
            else if (this->state == 1 || this->state == 3) { // Playing or Pause
                this->draw_map(p, e);
                this->input_update(p);
                if (this->state == 1) {
                    this->check_collisions(p, e);
                    if (p.hp <= 0) this->state = 2;
                }
                // Frame delay simulation
                #ifdef _WIN32
                Sleep(50);
                #endif
            }
            else if (this->state == 2) { // Game Over
                this->clear_screen();
                std::cout << \"=== GAME OVER ===\\n\";
                std::cout << \"Score Final: \" << p.score << \"\\n\";
                std::cout << \"Presiona Enter para reiniciar o Q para salir.\\n\";
                this->input_update(p);
            }
        }
        "
